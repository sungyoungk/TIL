## OCP, DIP 위반
```java
public class OrderServiceImpl implements OrderService {
  //    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
      private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
  }
  ```
- __DIP 위반:__  `OrderServiceImpl` 는 `DiscountPolicy` 인터페이스에 의존하면서 DIP를 지킨 것 같지만...
- 클래스 의존관계를 보면 추상(인터페이스) 뿐만 아니라 구현 클래스에도 의존하고 있다<img width="743" alt="스크린샷 2022-07-22 오전 12 45 49" src="https://user-images.githubusercontent.com/101084642/180257114-bee556a7-5ec2-490e-b75c-a5941780276b.png">

  - __추상(인터페이스) 의존 :__ `DiscountPolicy`
  - __구현 클래스 의존 :__  `FixDiscountPolicy` , `RateDiscountPolicy`
- __OCP 위반:__ OCP란 확장에는 열려있고 수정에는 닫혀있다!,<br>
🔎 그런데... 지금 코드는 기능을 확장해서 변경하면, 클라이언트 코드에 영향을 준다! 따라서 OCP를 위반한다
<img width="740" alt="스크린샷 2022-07-22 오전 12 44 58" src="https://user-images.githubusercontent.com/101084642/180256902-26addc8b-f316-47e7-bdab-acb7bccc001e.png">
<img width="743" alt="스크린샷 2022-07-22 오전 12 45 49" src="https://user-images.githubusercontent.com/101084642/180257144-c90d03ed-01b3-4cf6-9cab-d18b835aeee2.png">
<br>

### 😎 해결방법 <br>
➢ DIP 위반 추상에만 의존하도록 변경(인터페이스에만 의존)
<img width="737" alt="스크린샷 2022-07-22 오전 12 47 57" src="https://user-images.githubusercontent.com/101084642/180257541-c20a1ae1-606d-4d9c-b4da-732af7469adb.png">
 ```java
   public class OrderServiceImpl implements OrderService {
      //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
      private DiscountPolicy discountPolicy;
}
```

### 🔥 문제점
- 구현체 new(); 가 없으므로 null pointer exception 발생! <br>
### 🔥 해결방안
- OrderServiceImpl 에 DiscountPolicy 의 구현 객체를 대신 생성하고 주입 <br>

### AppConfig 클래스
- 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 클래스를 생성
```java
public class AppConfig {
      public MemberService memberService() {
          return new MemberServiceImpl(new MemoryMemberRepository());
}
      public OrderService orderService() {
          return new OrderServiceImpl(
                  new MemoryMemberRepository(),
                  new FixDiscountPolicy());
  } 
}
```

### 생성자 주입
 ```java

    public class MemberServiceImpl implements MemberService {
        private final MemberRepository memberRepository;
        public MemberServiceImpl(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
}
        public void join(Member member) {
            memberRepository.save(member);
}
        public Member findMember(Long memberId) {
            return memberRepository.findById(memberId);
} 
    }
```

### 결과
-  `MemberServiceImpl` 은 `MemoryMemberRepository` 를 의존하지 않는다! `MemberRepository` 인터페이스만 의존
- `MemberServiceImpl` 입장에서 생성자를 통해 어떤 구현 객체가 들어올지(주입될지)는 알 수 없음
- `MemberServiceImpl` 의 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부( AppConfig )에서 결정
- `MemberServiceImpl` 은 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다.

- 객체의 생성과 연결은 AppConfig 가 담당한다.
- __DIP 완성:__ `MemberServiceImpl` 은 `MemberRepository` 인 추상에만 의존하면 된다. 이제 구체 클래스를 몰라도 된다.
- __관심사의 분리:__ 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리되었다.

<img width="734" alt="스크린샷 2022-07-22 오전 12 57 46" src="https://user-images.githubusercontent.com/101084642/180259600-63981e5a-19f8-4618-bc53-31d9fcc903e4.png">

 * 본 포스팅은 개인 학습을 위한 기록 용도이며 모든 내용물의 저작권은 
 [인프런](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/unit/55350?tab=curriculum)에 있음
