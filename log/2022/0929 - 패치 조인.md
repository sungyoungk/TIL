# 📚 페치조인 fetch join

- 1:N 매핑에서 쿼리로 1에 해당하는 엔티티를 N에 조인을 걸어서 조회하면, 최초에 실제로 호출되는 엔티티 말고는 쿼리가 나가지 않음(지연로딩)
- 그런데 조회를 한 두명만 하는것도 아니고.. 몇백명이 막 한다면! 특히 검색 같은것 할때... 조건에 맞는 검색이 여러개이고 그때마다 쿼리가 따로따로 주르르륵 그때마다 나간다면...
- 이럴때 fetch 조인을 사용함
- fetch 조인은 즉시로딩과 같은데 처음에 쿼리가 나갈때 연관되는 엔티티를 한번에 같이 쿼리를 날림
- 그러면 영속성 컨텍스트에 저장되어 있으므로 다음번에는 따로 쿼리를 안날려도 됨
-  N + 1 문제는 최초 쿼리를 날렸를때 조회 대상인 엔티티 N개 만큼 쿼리가 나가게되는 현상임. 이런 문제를 fetch 조인으로 해결할 수 있음

- 그런데... 또 한가지 문제가 있음
- 1:N 매핑을 DB 테이블 입장에서 보면 결국 테이블 줄 하나에 각각 매핑이 되어야함
- 그래서 중복 결과가 출력됨 예를 들어서 팀A 에 멤버1, 멤버2 가 있으면
- 디비 테이블은 중간에 빈칸을 넣을 수 없으므로 
- 팀A- member1, member2
- 팀A - member1, member 2 
- 이렇게 테리브이 두개가 쌓이게 됨

- 해결법으로 distict 문을 사용하면됨
- SQL distinct 명령어는 결과값이 완전히 같은것만 제외시켜 주므로
- 맵핑된 멤버들의 PK가 다르면 제외시켜버림

- 그런데 갓 JPA 느님은 엔티티 중복도 조회해서 N+1 이 문제를 해결할 수 있음
